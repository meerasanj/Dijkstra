
Analysis & Design--

Problem Description/Specification: 
This project implements Dijkstra's algorithm to read from an input file, produce a summary table of the shortest paths from a user-selected start vertex, and detect the presence of a cycle by utilizing the Depth-First Search algorithm. My algorithm utilizes various data structures such as vectors, queues, stacks, arrays, as well as using operations from the Graph class. The input consists of a text file containing edges and their weights, formatted as follows: Origin; Destination; Trip-length. The output of my algorithm consists of a printed list of what cities the weighted graph was built for, a summary table that shows the shortest path from a specified start vertex to all other vertices in the graph, and whether or not the graph has a cycle.

Outline of Graph Class:
The Graph class provides a representation of a graph data structure and contains various methods to manipulate and interact with this structure. By using templates, the Graph class can be used with different types of vertices without modifying its implementation. This allows for flexibility in handling various types of graph data. Overall, the Graph class contains useful  operations that provide functionality for creating, manipulating, traversing, and analyzing graph structures effectively. I used 4 main methods from the graph class. The AddVertex() method adds a vertex to the graph and the AddEdge() method adds an edge between two vertices with a specified weight. I used these methods to construct the graph in my buildGraphFromFile() method. The WeightIs() method retrieves the weight of the edge between two vertices. The GetToVertices() method retrieves the vertices adjacent to a given vertex and stores them in a queue. During my dijkstra() method, I used the WeightIs() method to retrieve the weights of edges and the GetToVertices() method to obtain adjacent vertices. I also used the GetToVertices() method in my DFS() method. The Graph class also contains other methods. The MakeEmpty() clears the graph and removes all vertices and edges. The IsEmpty() method checks if the graph is empty. The IsFull() method checks if the graph is full, which is when the maximum number of vertices has been reached. The ClearMarks() method clears all marks associated with vertices. The MarkVertex() method marks a specific vertex. The IsMarked() method checks if a vertex is marked.

Client Algorithm: 
The program starts by reading from the input file containing the graph data. Each line in the file represents an edge between two vertices and the weight of that edge. The program parses this information to build the graph data structure by calling buildGraphFromFile(). This method constructs the graph based on the parsed input data. It adds vertices and edges to the graph, ensuring that each vertex and edge is represented correctly. 

After building the graph, the program calls the startVertex() method, which prints out a sorted list of all vertices. The user is then prompted to enter the start vertex from which they want to find the shortest paths to all other vertices. It validates the user input to ensure that the entered vertex exists in the graph. If the user selects an invalid starting vertex, the user is informed and allowed to re-enter the start vertex. 

Once the start vertex is selected, my program applies Dijkstra's algorithm by calling dijkstra() to find the shortest paths from the start vertex to all other vertices in the graph. In this method, a series of four parallel arrays are constructed to represent the names of the vertices, the boolean status of whether the vertex has already been visited, the integers representing the total distance used in reaching this vertex, and the strings representing the previous vertex visited before reaching a vertex. The data corresponding to the starting vertex is then printed. The following algorithm is repeated until all vertices have been marked. The method examines each vertex that is adjacent to the current vertex and determines the weight value between the them. If an adjacent vertex is unmarked and its distance value is greater than the sum of the weight value plus the distance of the current vertex, its distance value is reset to the smaller sum. Then, the current vertex is set equal to the vertex wiith the smallest distance value of all unmarked vertices. The data corresponding to the current marked vertex is then printed and its value in the visited array is set to true. 

My algorithm then calls the hasCycle() method to serve as the entry point of cycle detection. In this method, I created a boolean array called visited to keep track of visited vertices in addition to a boolean array called inStack to keep track of which vertices are in the current traversal. I also created a stack to keep track of the vertices in the current traversal. I then initialize these arrays by setting the visited and inStack arrays to false for all vertices and pushing each vertex to the stack. I use a while loop to traverse through all vertices in the graph. If a vertex has not been visited yet (for all vertices) and the DFS() method returns true, then there is a cycle in the graph and this message is shown to the user. Otherwise, if no cycle is present, a message is printed to the user that the graph does not contain a cycle. When the DFS() method is called for each vertex, this method follows the algorithm of depth-first search. First, the method sets the currentVertex as true for visited and inStack, and pushes the currentVertex onto the verticesStack. This helps to prevent revisiting the same vertex and avoid infinite loops. Then, the GetToVertices() method from the graph class is used to store the adjacent vertices of the current vertex in a queue. The DFS() method then interates through all vertices in the adjacent vertices queue. If the adjacent vertex has not been visited, the DFS method is recursively called, which ensures that the DFS traversal explores all connected vertices in the graph. Thus, if adjacent vertex is in the current traversal path (in the stack), then a cycle is detected and the method returns true. Following the while loop, the current vertex is removed from the stack and its value in inStack is set to false. If no cycle is found during DFS traversal, the function returns false.

I also utilized several helper methods to simplify code and perform different tasks within the main algorithms. The method, initializeArrayInfo(), is used to initialize the series of four parallel arrays and was utilized in dijkstra(). The getIndex() method returns the index number of a given vertex by traversing through the verticesList vector. The printSummaryTableRow() method prints one row of Dijkstra’s summary table, outputting the vertex name, distance, and previous. This method is used to print the startVertex as well as each current vertex in dijkstra(). The findMinDistance() method locates the index value of the vertex with with the minimum distance among the current unmarked vertices by traversing through the vertices and using conditional statements. This method was useful in setting the current vertex to the unmarked vertex wiith the minimum distance of all unmarked vertices during the while loop in dijkstra(). The isValidVertex() method uses the find() member function of <string> to see if the given vertex is located in the verticesList vector. I used this method to allow users to re-enter the starting vertex value in the case of invalid user input. I also created a boolean method named allVisited() to check if all vertices in verticesList have been visited. I used this method for the outer while loop in dijkstra to ensure that the algorithm is repeated until all vertices were marked. 

ginfile2.dat Adjacency Matrix Example--
      V1   V2   V3   V4   V5   V6   V7
  ---------------------------------------
V1 |  0    2    4    1    0    0    0  
V2 |  2    0    0    3    10   0    0  
V3 |  4    0    0    2    0    5    0  
V4 |  1    3    2    0    2    8    4  
V5 |  0    10   0    2    0    0    6  
V6 |  0    0    5    8    0    0    1  
V7 |  0    0    0    4    6    1    0  


Step by step guide to the shortest paths from V1 using Dijkstra’s Algorithm--
1.First, we should set up a table to store our vertices, mark (boolean representation of whether this vertex has been visited), distance, and previous (where the vertex was last).
2. Mark the starting vertex (V1) as visited (represented by T0), set its distance to 0, and set the previous to be blank. 
3. Now we can get greedy! Continue this step until the entire graph is covered. Identify the smallest non-marked vertex. Label this as marked and label the distance and previous of its adjacent vertices. Keep in mind that marked vertices should not be touched. Also, distance must include the previous distance and should be updated if a smaller distance is found.

Let’s begin the algorithm: 
We can label V1 as T0 and examine its adjacent vertices. Based on the input file, it can be seen that V1 has adjacent vertices of V2 (distance of 2), V3 (4), and V4 (1). We can now label the distances and previous for V2, V3, and V4, while leaving all of them unmarked. 

The current smallest non-marked vertex is now V4 with a distance of 1. We can mark this as T1 and examine the adjacent vertices of V4. Based on the input file, V4 has adjacent vertices of V1 (distance of 1), V2 (3), V3 (2), V5 (2), V6 (8), and V7 (4). We can now label the distances and previous for V3, V5, V6, and V7, while leaving the marked vertices (V1) and vertices with smaller distances (V2) unmarked. The updated distance for V3 will include prior distances, so it will be 1+2 = 3. Furthermore, the distances for V5, V6, and V7 must include V4’s distance, so they will respectively be 3, 9, and 5.

Now, the current smallest non-marked vertex will be V2 with its distance of 2. We can mark this as T2 and examine the adjacent vertices of V2. Based on the input file, V2 has adjacent vertices of V1 (2), V4 (3), and V5 (10). V1 is already marked so it should not be touched. Furthermore, V4 and V5 have smaller distances, so they do not need to be updated.

The next smallest non-marked vertex is a tie between V3 (3) and V5 (3). Since the distances are the same, it does not matter which of these vertices we choose to look at first. This step by step guide will mark V3 as T3 and examine the adjacent vertices of V3. Based on the input file, V3 has adjacent vertices of V1 (4), V4 (2), and V6 (5). V1 is already marked so it should not be touched. Furthermore, V4 and V6 have smaller distances, so they do not need to be updated.

V5 is the next smallest non-marked vertex with a distance of 3. We can mark this vertex as T4 and examine its adjacent vertices. Based on the input file, V5 has adjacent vertices of V2 (10), V4 (2), and V7 (6). However, V2, V4, and V7 all have smaller distances, so they do not need to be updated. 

The next smallest non-marked vertex is V7 with a distance of 5. We can mark V7 as T5 and examine its adjacent vertices. Based on the input file, V7 has adjacent vertices of V4 (4), V5 (5), and V6 (1). V4 and V5 already have smaller distances so they do not need to be updated. The updated distance for V6 will include prior distances, so it will be 5+1 = 6 and its previous will be set to V7. 

The last non-marked vertex is V6 with a distance of 6. We can mark V6 as T6 and examine its adjacent vertices. Based on the input file, V6 has adjacent vertices of V3 (5), V4 (8), and V7 (1). However, V3, V4, and V7 all have smaller distances, so they do not need to be updated. 

All vertices have now been marked, meaning that the entire graph has been convered! Dijkstra’s algorithm is now complete and we can see the shorted paths from V1 to all other vertices in the graph. For example, it can be seen from the summary table that the shortest distance from V1 to V7 is 5. 

----------------------------------------------------------------------------------------
Vertex                 Mark                Distance                 Previous
                
V1                     T0                  0                        N/A                      
V4                     T2                  1                        V1                       
V2                     T3                  2                        V1                       
V5                     T1                  3                        V4                       
V3                     T4                  3                        V4                       
V7                     T6                  5                        V4                       
V6                     T5                  6                        V7                       
----------------------------------------------------------------------------------------

